---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by CHH.
--- DateTime: 2021/3/12 14:08
---
---
---#redissonReadLock的加锁脚本，KEYS[1] 为传入的key  ARGV[1]为加锁时长  ARGV[2]为线程id相关信息，用于判断是否重入
---
local mode = redis.call('hget', KEYS[1], 'mode');
if (mode == false) then
    redis.call('hset', KEYS[1], 'mode', 'read');
    redis.call('hset', KEYS[1], ARGV[2], 1);
    redis.call('set', KEYS[2] .. ':1', 1);
    redis.call('pexpire', KEYS[2] .. ':1', ARGV[1]);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end ;
if (mode == 'read') or (mode == 'write' and redis.call('hexists', KEYS[1], ARGV[3]) == 1) then
    local ind = redis.call('hincrby', KEYS[1], ARGV[2], 1);
    local key = KEYS[2] .. ':' .. ind;
    redis.call('set', key, 1);
    redis.call('pexpire', key, ARGV[1]);
    local remainTime = redis.call('pttl', KEYS[1]);
    redis.call('pexpire', KEYS[1], math.max(remainTime, ARGV[1]));
    return nil;
end ;
return redis.call('pttl', KEYS[1]);

---#redissonWriteLock的加锁脚本  KEYS[1] 为传入的key  ARGV[1]为加锁时长  ARGV[2]为线程id相关信息，用于判断是否重入
local mode = redis.call('hget', KEYS[1], 'mode');
if (mode == false) then
    redis.call('hset', KEYS[1], 'mode', 'write');
    redis.call('hset', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end ;
---如果当前为读锁时，判断是否是同一线程对同一个key进行加锁，如果是则加1且同时延长锁时间
if (mode == 'write') then
    if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then
        redis.call('hincrby', KEYS[1], ARGV[2], 1);
        local currentExpire = redis.call('pttl', KEYS[1]);
        redis.call('pexpire', KEYS[1], currentExpire + ARGV[1]);
        return nil;
    end ;
end ;
---返回key剩余时间
return redis.call('pttl', KEYS[1]);